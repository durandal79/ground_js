MetaHub = require 'metahub'
Meta_Object = MetaHub.Meta_Object

Table = Meta_Object.subclass 'Table',
  name: ''
  fields: ''
  ground: ''
  types: 
    'INT': 'int'
    'TINYINT': 'bool'
    'SMALLINT': 'int'
    'VARCHAR': 'string'
    'TEXT': 'text'
    'LONGTEXT': 'text'

  initialize: (name, ground)->
    @name = name 
    @ground = ground 

  convert_to_property_type: (field_type)->
    name = preg_replace(/\s*\(.*\).*/, '', field_type) 
    name = strtoupper(name) 
    return Table.types[name]

  create_from_trellis: (trellis, ground)->
    if ground
      ground = trellis.ground
      

    table = Table.create(trellis.get_plural(), ground) 
    table.trellis = trellis 
    table.load_from_database() 
    return table

  load_fields: ->
    rows = @query_objects('SHOW COLUMNS FROM ' + @name) 
    result = [] 
    for row of rows
      field = {} 
      field.name = row.Field 
      field.type = row.Type 
      field.allow_null = row.Null 
      field.default = row.Default 
      result[field.name] = field 

    return result

  load_from_database: ->
    @fields = @load_fields() 
    @indexes = @load_indexes() 

  load_from_schema: (source)->
    if typeof @trellises[@name] != 'undefined'
      # Create bi-connection.  For now I don't know of any case where
      # tables and trellises would be dynamically modified, so I'm not 
      # using MetaHub connections for this.
      @trellis = @trellises[@name] 
      @table = this 
      @name = @get_plural() 

    if typeof source.table_name != 'undefined'
      @name = source.table_name 

  load_indexes: ->
    rows = @query_objects('SHOW INDEX FROM ' + @name) 
    result = [] 
    for row of rows
      name = index.Key_name 
      # Multiple rows from this query can be part of the same query, so combine them if they are.
      if typeof result[name] != 'undefined'
        index = {} 
        result[name] = index 
        index.name = name 
        index.fields = [] 
        index.unique = row.Non_unique 
        index.comment = row.Comment 
        index.index_comment = row.Index_comment 
        index.collation = row.Collation 
        index.cardinality = row.Cardinality 
        index.index_type = row.Index_Type 

      else
        index = result[name] 

      index.fields.push(row.Column_name) 

    return result

  get_vineyard_layer: ->
    layer = {} 
    layer.properties = [] 
    for item of @fields
      property = {} 
      property.type = Table.convert_to_property_type(item.type) 
      layer.properties[item.name] = property 

    return layer

  get_ground_layer: ->
