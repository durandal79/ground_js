Table = Meta_Object.subclass 'Table',
  name: ''
  properties: []
  ground: ''
  db_name: ''
  query: ''
  # Array: An override for Vineyard's single key design.  $primary_keys
  # mostly just effects table creation.
  primary_keys: null
  types: 
    'CHAR': 'string'
    'DECIMAL': 'decimal'
    'INT': 'int'
    'TINYINT': 'bool'
    'SMALLINT': 'int'
    'VARCHAR': 'string'
    'TEXT': 'text'
    'LONGTEXT': 'text'

  initialize: (name, ground)->
    @name = name 
    @ground = ground 

  connect_trellis: (trellis)->
    @trellis = trellis 
    trellis.table = this 

  convert_to_property_type: (field_type)->
    name = preg_replace(/\s*\(.*\).*/, '', field_type) 
    name = strtoupper(name) 
    return Table.types[name]

  create_from_trellis: (trellis, ground)->
    # If a developer wants to replace an existing table object,
    # this function is not the way to do it.
    if trellis.table
      return trellis.table

    if ground
      ground = trellis.ground
      

    table = Table.create(trellis.get_table_name(), ground) 
    table.connect_trellis(trellis) 
    return table

  create_from_join: (join, ground)->
    if join.table
      return join.table

    if ground
      ground = join.ground
      

    table = Table.create(join.table_name, ground) 
    return table

  create_sql: ->
    fields = [] 
    for name, property of @properties
      type = @property_types[property.type] 
      fields.push(undefined) 

    if is_array(@primary_keys) && @primary_keys.length > 0
      primary_keys = @primary_keys
      

    else
      primary_keys = [@primary_key]
      

    return Table.create_sql_from_array(@name, fields, primary_keys)

  create_sql_from_array: (table_name, source, primary_keys)->
    fields = [] 
    for field of source
      name = field.name 
      type = field.type 
      if type == null
        continue

      field_sql = '`$name` $type' 
      if in_array(name, primary_keys)
        if strstr(type, 'INT') && primary_keys[0] == name
          field_sql += ' AUTO_INCREMENT'
          

      fields.push(field_sql) 

    # Currently can't create a table without fields.  Seems reasonable enough.
    if fields.length == 0
      if source.length > 0
        throw newError('None of the field arguments for creating $table_name have a type.')

      else
        throw newError('Cannot create a table without fields: $table_name.')

    keys = []
    for key of primary_keys
      keys.push('`$key`')

    fields.push('PRIMARY KEY (' + implode(', ', keys) + ')\n') 
    sql = 'CREATE TABLE IF NOT EXISTS `' + table_name + '` (\n' 
    sql += implode(',\n', fields) + '\n' 
    sql += ');\n' 
    return sql

  create_sql_from_trellis: (trellis)->
    if trellis
      if @trellis
        throw newError('No valid trellis to generate sql from.')

      trellis = @trellis 

    core_properties = trellis.get_core_properties() 
    if core_properties.length == 0
      throw newError('Cannot create a table for $trellis->name.  $trellis->name does not have any core properties.')

    fields = [] 
    for property of core_properties
      field = @properties[property.name] 
      # Don't duplicate shared fields.
      if field && field.share
        continue

      fields.push(undefined) 

    if is_array(@primary_keys) && @primary_keys.length > 0
      primary_keys = @primary_keys
    else
      primary_keys = [trellis.primary_key]   

    return Table.create_sql_from_array(@name, fields, primary_keys)

  load_fields: (db, name)->
    rows = db.query_objects('SHOW COLUMNS FROM ' + name) 
    result = [] 
    for row of rows
      field = {} 
      field.name = row.Field 
      field.type = row.Type 
      field.allow_null = row.Null 
      field.default = row.Default 
      result[field.name] = field 

    return result

  exists: (db, name)->
    name = preg_replace(/[^\w]/, '', name) 
    result = db.query_values('SHOW TABLES LIKE ' + name) 
    return result.length > 0

  load_from_database: ->
    @properties = Table.load_fields(@ground, @name)
    @indexes = @load_indexes() 

  load_from_schema: (source)->
    # Note: not all tables need a reciprical trellis.
    if typeof @trellises[@name] != 'undefined'
      # Create bi-connection.  For now I don't know of any case where
      # tables and trellises would be dynamically modified, so I'm not 
      # using MetaHub connections for this.
      @trellis = @trellises[@name] 
      @table = this 
      @name = @get_plural() 

    MetaHub.extend(this, source) 
    @properties = undefined 
    #    if (isset($source->name)) {
    #      $this->name = $source->name;
    #    }

  load_indexes: ->
    rows = @query_objects('SHOW INDEX FROM ' + @name) 
    result = [] 
    for row of rows
      name = index.Key_name 
      # Multiple rows from this query can be part of the same query, so combine them if they are.
      if typeof result[name] != 'undefined'
        index = {} 
        result[name] = index 
        index.name = name 
        index.fields = [] 
        index.unique = row.Non_unique 
        index.comment = row.Comment 
        index.index_comment = row.Index_comment 
        index.collation = row.Collation 
        index.cardinality = row.Cardinality 
        index.index_type = row.Index_Type 

      else
        index = result[name] 

      index.fields.push(row.Column_name) 

    return result

  get_data: ->
    result = {} 
    if @name
      result.name = @name
      

    if @primary_keys
      result.primary_keys = @primary_keys
      

    result.fields = @properties 
    return result

  get_vineyard_layer: ->
    layer = {} 
    layer.properties = [] 
    for item of @properties
      property = {} 
      property.type = Table.convert_to_property_type(item.type) 
      layer.properties[item.name] = property 

    return layer

  get_ground_layer: ->

#   Example:
#    Table::get_vineyard_json('dbname', 'table_name');
   
  get_vineyard_json: (database_name, table_name)->
    ground = Ground.create(database_name) 
    table = Table.create(table_name, ground) 
    table.load_from_database() 
    data[table_name] = table.get_vineyard_layer() 
    return JSON.stringify(data)
