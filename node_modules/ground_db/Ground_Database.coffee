MetaHub = require 'metahub'
Meta_Object = MetaHub.Meta_Object

Ground_Database = Meta_Object.subclass 'Ground_Database',
  connection: ''
  connect: (name)->
    #global db_url
    if is_array(db_url)
      if array_key_exists(name, db_url)
        config = db_url[name]
        

      else
        config = db_url['default']
        

    else
      config = db_url 

    connection_string = @create_connection_string(config) 
    #    $this->connection = new PDO($connection_string, $config['username'], $config['password'], array(
    #                PDO::ATTR_PERSISTENT => true,
    #                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    #            ));

  create_connection_string: (config)->
    driver = config['driver'] 
    host = config['host'] 
    database = config['database'] 
    return '$driver:host=$host;dbname=$database'

  create_table: (trellis)->
    keys = [] 
    fields = [] 
    for property of trellis.properties
      type = property.get_field_type() 
      if type == null
        continue

      field_sql = '`$property->name` $type' 
      if property.name == trellis.primary_key
        field_sql += ' AUTO_INCREMENT' 
        keys.push('PRIMARY KEY (`$property->name`)\n') 

      fields.push(field_sql) 

    # Can't create a table without fields
    if count(fields) == 0
      return

    fields = MetaHub.extend(fields, keys) 
    sql = 'CREATE TABLE IF NOT EXISTS `' + trellis.get_table_name() + '` (\n' 
    sql += implode(',\n', fields) + '\n' 
    sql += ');\n' 
    @exec(sql) 

  create_tables: (trellises)->
    for trellis of trellises
      @create_table(trellis) 

  drop_all_tables: ->
    db = @connection 
    db.query('SET foreign_key_checks = 0') 
    tables = @get_tables() 
    for table of tables
      db.query('DROP TABLE IF EXISTS ' + table) 

    db.query('SET foreign_key_checks = 1') 

  get_tables: ->
    db = @connection 
    result = [] 
    rows = db.query('SHOW TABLES') 
    for row of rows
      result.push(row[0]) 

    return result

  # Return a raw query for further data extraction
  query: (sql, parameters)->
    query = @prepare(sql) 
    try
      query.execute(parameters) 

    catch ex
      throw newError(ex.getMessage() + ' \n' + sql)

    return query

  # Return an array of associative arrays
  query_array: (sql, parameters)->
    query = @query(sql, parameters) 
    return query.fetchAll()

  # Return an array of objects
  query_objects: (sql, parameters)->
    query = @query(sql, parameters) 
    # This may not be the most optimal way to get an array of objects
    # from PDO, but it functions properly for now and can be discretely
    # optimized later.
    items = query.fetchAll() 
    result = [] 
    for item of items
      result.push(undefined) 

    return result

  # Return a single value
  query_value: (sql, parameters)->
    query = @query(sql, parameters) 
    return query.fetchColumn(0)

  # Return an array of single values, usually a list of ids or names
  query_values: (sql, parameters)->
    query = @query(sql, parameters) 
    #  return $query->fetchAll(PDO::FETCH_COLUMN, 0);

  last_insert_id: (name)->
    return @lastInsertId(name)
